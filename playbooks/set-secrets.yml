---
- name: Manage Freva secrets and K8s Secret
  hosts: localhost
  gather_facts: false
  vars_files:
    - vars.yml

  tasks:
    - name: Load vaulted secrets
      include_vars:
        file: "{{ secrets_file }}"
        name: freva_secrets

    # -- Required inputs from vault -----------------------------
    - name: Fail if ADMIN_PASSWORD missing/empty
      fail:
        msg: "ADMIN_PASSWORD must be defined in {{ secrets_file }} (vault)."
      when: freva_secrets.ADMIN_PASSWORD is not defined or (freva_secrets.ADMIN_PASSWORD | length) == 0

    - name: Fail if ADMIN_USER missing/empty
      fail:
        msg: "ADMIN_USER must be defined in {{ secrets_file }} (vault)."
      when: freva_secrets.ADMIN_USER is not defined or (freva_secrets.ADMIN_USER | length) == 0


    - name: Ensure OIDC_CLIENT_SECRET exists (can be empty for public client)
      set_fact:
        freva_secrets: "{{ freva_secrets | combine({'OIDC_CLIENT_SECRET': (freva_secrets.OIDC_CLIENT_SECRET | default(''))}) }}"

    # -- Derive the managed set automatically -------------------
    - name: Compute derived key sets
      set_fact:
        _username_keys: "{{ (username_keys | default([])) + (extra_username_keys | default([])) }}"
        _password_keys: "{{ (password_keys | default([])) + (extra_password_keys | default([])) }}"
        managed_keys: >-
          {{
            ['ADMIN_USER','ADMIN_PASSWORD','MYSQL_ROOT_PASSWORD','OIDC_CLIENT_SECRET']
            + (username_keys | default([]))
            + (extra_username_keys | default([]))
            + (password_keys | default([]))
            + (extra_password_keys | default([]))
          }}

    # -- Normalize & fill ---------------------------------------
    - name: Mirror MYSQL_ROOT_PASSWORD from ADMIN_PASSWORD
      set_fact:
        freva_secrets: "{{ freva_secrets | combine({'MYSQL_ROOT_PASSWORD': freva_secrets.ADMIN_PASSWORD}) }}"

    - name: Fill missing usernames
      set_fact:
        freva_secrets: >-
          {{
            freva_secrets |
            combine({
              item: (freva_secrets[item] | default(
                lookup('community.general.random_pet', words=2, separator='-')
              ))
            }, recursive=True)
          }}
      loop: "{{ _username_keys }}"
      when: freva_secrets[item] is not defined or (freva_secrets[item] | length) == 0

    - name: Fill missing passwords/tokens (OIDC_CLIENT_SECRET is excluded on purpose)
      set_fact:
        freva_secrets: >-
          {{
            freva_secrets |
            combine({
              item: (freva_secrets[item] | default(
                lookup('password', '/dev/null', length=32, chars='ascii_letters,digits')
              ))
            }, recursive=True)
          }}
      loop: "{{ _password_keys }}"
      when: freva_secrets[item] is not defined or (freva_secrets[item] | default('') | string | length) == 0
      # no_log: true

    - name: Normalize to exactly the managed keys
      set_fact:
        normalized_secrets: "{{ dict(managed_keys | zip(managed_keys | map('extract', freva_secrets))) }}"

    # -- Persist back to the vault (atomic) ---------------------
    - name: Create temp file for plaintext YAML
      tempfile:
        state: file
        suffix: .yml
      register: tmp_yaml

    - name: Write plaintext YAML
      copy:
        dest: "{{ tmp_yaml.path }}"
        content: "{{ normalized_secrets | to_nice_yaml }}"
        mode: "0600"
      no_log: true

    - name: Encrypt into final vault file
      command:
        argv:
          - ansible-vault
          - encrypt
          - "--vault-id"
          - "{{ vault_id }}"
          - "--output"
          - "{{ secrets_file }}"
          - "{{ tmp_yaml.path }}"
      changed_when: true

    - name: Remove temp file
      file:
        path: "{{ tmp_yaml.path }}"
        state: absent

    # -- (Optional) write a manifest to disk for auditing -------
    - name: Ensure manifest directory exists
      file:
        path: "{{ manifest_path | dirname }}"
        state: directory
        mode: "0755"

    - name: Render Secret manifest to file
      copy:
        dest: "{{ manifest_path }}"
        mode: "0600"
        content: |
          apiVersion: v1
          kind: Secret
          metadata:
            name: {{ k8s_secret_name }}
            namespace: {{ k8s_namespace }}
            labels:
              app.kubernetes.io/name: {{ k8s_secret_name }}
              app.kubernetes.io/part-of: freva
              app.kubernetes.io/component: platform
              app.kubernetes.io/managed-by: ansible
          type: Opaque
          stringData:
          {% for k, v in normalized_secrets.items() %}
            {{ k }}: "{{ v }}"
          {% endfor %}
      no_log: true

    # -- Apply to Kubernetes (create or patch without overwrite) -
    - name: Read existing K8s Secret
      k8s_info:
        api_version: v1
        kind: Secret
        name: "{{ k8s_secret_name }}"
        namespace: "{{ k8s_namespace }}"
      register: existing_secret
      failed_when: false

    - name: Build stringData payload
      set_fact:
        secret_stringdata: "{{ dict(normalized_secrets) }}"
      no_log: true

    - name: Create K8s Secret with labels if absent
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: "{{ k8s_secret_name }}"
            namespace: "{{ k8s_namespace }}"
            labels:
              app.kubernetes.io/name: "{{ k8s_secret_name }}"
              app.kubernetes.io/part-of: "freva"
              app.kubernetes.io/component: "platform"
              app.kubernetes.io/managed-by: "ansible"
          type: Opaque
          stringData: "{{ secret_stringdata }}"
      when: (existing_secret.resources | default([])) | length == 0
      no_log: true

    - name: Determine existing keys
      set_fact:
        existing_keys: >-
          {{
            (existing_secret.resources[0].data | default({})).keys()
            if (existing_secret.resources | default([])) | length > 0 else []
          }}

    - name: Patch only missing keys (do not overwrite)
      k8s:
        state: present
        merge_type: merge
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: "{{ k8s_secret_name }}"
            namespace: "{{ k8s_namespace }}"
          type: Opaque
          stringData: >-
            {{
              dict(
                secret_stringdata
                | dict2items
                | rejectattr('key','in', existing_keys | list)
                | list
                | items2dict
              )
            }}
      when:
        - (existing_secret.resources | default([])) | length > 0
        - dict(
            secret_stringdata
            | dict2items
            | rejectattr('key','in', existing_keys | list)
            | list
            | items2dict
          ) | length > 0
      no_log: true
